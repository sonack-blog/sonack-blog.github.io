<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KMP算法</title>
      <link href="/2021/12/22/c18e452314ae/"/>
      <url>/2021/12/22/c18e452314ae/</url>
      
        <content type="html"><![CDATA[<p><strong>KMP</strong> (Knuth-Morris-Pratt) 是一种高效的串匹配算法，其发明者是 D.E.Knuth、J.H.Morrs 和 VR.Pratt. 三人，作用是从主串s中查找模式串p的所有出现位置。</p><span id="more"></span><p>设主串s的长度为n, 模式串p的长度为m。</p><h1 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h1><p>最暴力的做法是依次枚举s和p的匹配起始位置，并验证到p的末尾是否完全匹配成功，复杂度为 $O(m*n)$。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        <span class="hljs-keyword">if</span> (s[i + j] != p[j])<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (j == m) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Match Success at s[%d]."</span>, i);<br>    }<br>}<br></code></pre></div></td></tr></tbody></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法充分利用失配时已匹配前缀的信息，避免每次移动i(<code>i++</code>)，再从头匹配s[i:]与p，其时间复杂度为$O(m+n)$。</p><p>为方便处理边界，s和p下标从1开始。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://www.acwing.com/problem/content/description/833/">ACwing-831. KMP字符串</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">char</span> p[N], s[M];<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> ne[N]; <span class="hljs-comment">// 由于 C++ 中 next 变量已经在其他的头文件定义了, 所以这里将 next 数组命名为 ne</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>; <span class="hljs-comment">// 读入p和s时, 从下标为1的位置开始读入</span><br>    <span class="hljs-comment">// 先求解p串的next数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j]; <span class="hljs-comment">// 回溯j</span><br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>        ne[i] = j;<br>    }<br><br>    <span class="hljs-comment">// 进行s串和p串的匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++) {<br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j]; <span class="hljs-comment">// 回溯j</span><br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span>(j == n) {<br>            <span class="hljs-comment">// 匹配完成</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, i - n);<br>            j = ne[j];<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h2 id="next数组含义"><a href="#next数组含义" class="headerlink" title="next数组含义"></a>next数组含义</h2><p>next[i]含义为子串p[1…i]的最大前缀、后缀匹配长度，即前缀集合和后缀集合的交集串的最大长度。</p><p>对于字符串a[1…n]，其所有前缀子串集合为{ a[1], a[1,2], …, a[1,…,n-1] }，共n-1个（不包含自身）；所有后缀子串集合为{ a[n-1], a[n-2, n-1], …, a[2…n-1] }，共n-1个。</p><p>以p=”ababac”为例:</p><ul><li>next[1]=0，恒成立</li><li>next[2]=0，ab</li><li>next[3]=1，aba的最大匹配是a，长度为1</li><li>next[4]=2，abab的最大匹配是ab，长度为2</li><li>next[5]=3，ababa的最大匹配是aba，长度为3</li><li>next[6]=0，ababac的最大匹配为空，长度为0</li></ul><h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><p>若已知next数组，则s和p的匹配过程如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = next[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++;<br>    <span class="hljs-keyword">if</span> (j == m) {<br>        <span class="hljs-comment">// 匹配成功, 返回主串的起始坐标i, 下标从1开始</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, i - m + <span class="hljs-number">1</span>);<br>        j = next[j]; <span class="hljs-comment">// 继续后续可能的匹配</span><br>    }<br>}<br></code></pre></div></td></tr></tbody></table></figure><h2 id="next数组计算"><a href="#next数组计算" class="headerlink" title="next数组计算"></a>next数组计算</h2><p>类似于匹配过程, p[i]和p[j+1]进行匹配，p[1]=0，所以i从2开始，j从1开始：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++) {<br>    <span class="hljs-comment">// 错开一位进行匹配, 每次匹配 i 和 j + 1 位, 第一次则匹配 2 和 1</span><br>    <span class="hljs-comment">// 当前面有匹配上的部分时, 看看当前位是否匹配, 若不匹配, 则回溯 j</span><br>    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = next[j];<br>    <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j++; <span class="hljs-comment">// 该位匹配上了, 则 j 往后移动一位，类似DP思想</span><br>    next[i] = j; <span class="hljs-comment">// 当前位置的 next[i] = j</span><br>}<br></code></pre></div></td></tr></tbody></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://juejin.cn/post/6960976586766188551">一文看懂KMP（看毛片）算法</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
